<!DOCTYPE html>
<html>
<head>
    <title>BHChat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, where, addDoc, serverTimestamp, orderBy, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the Canvas environment
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        let userId = null;
        let isAuthReady = false;

        // Sign in anonymously or with the provided token
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                isAuthReady = true;
                console.log("Firebase Auth Ready. User ID:", userId);

                // Start the app logic after authentication
                if (localUsername) {
                    joinRoom();
                } else {
                    statusMessage.textContent = 'Please enter a username and room name, then click Join.';
                    joinButton.disabled = false;
                }
            } else {
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Firebase sign-in error:", error);
                }
            }
        });
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }
        .container {
            width: 90%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        h1 { font-size: 2em; text-align: center; margin-bottom: 20px; }
        h2 { font-size: 1.5em; text-align: center; }
        h3 { font-size: 1.2em; margin-bottom: 10px; }
        p { font-size: 1em; }

        .chat-section {
            display: flex;
            gap: 20px;
        }
        .sidebar {
            width: 250px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            padding: 20px;
        }
        .chat-container {
            flex-grow: 1;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 400px;
        }
        #chatbox {
            flex-grow: 1;
            overflow-y: auto;
            border-bottom: 1px solid #ddd;
            margin-bottom: 10px;
            padding: 5px;
        }
        #chat-input-form { display: flex; }
        #chat-input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-right: 10px;
        }
        #send-button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #send-button:hover { background-color: #0056b3; }
        #upload-image-button {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-right: 10px;
        }
        .message { margin: 5px 0; }
        .my-message { text-align: right; color: #007bff; }
        .message img { max-width: 200px; display: block; }
        .active-rooms-container {
            margin-top: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            padding: 20px;
        }
        ul { list-style-type: none; padding: 0; }
        li {
            margin: 5px 0;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
        }
        li.active-chat {
            background-color: #e2e8f0;
            font-weight: bold;
        }
    </style>
</head>
<body>

<div class="container">
    <h1 class="text-3xl text-center font-bold mb-4">BHChat</h1>

    <div id="controls" class="text-center mb-4 p-4 bg-white rounded-lg shadow">
        <input type="text" id="username-input" placeholder="Enter your username" class="p-2 border rounded mr-2">
        <input type="text" id="room-input" placeholder="Enter Room Name" value="default-room" class="p-2 border rounded mr-2">
        <button id="join-button" class="p-2 px-4 bg-blue-500 text-white rounded">Join Room</button>
        <button id="refresh-rooms-button" class="p-2 px-4 bg-gray-500 text-white rounded">Refresh Active Rooms</button>
        <p id="status-message" class="mt-2 text-gray-600">Please enter a username and room name, then click Join.</p>
        <div id="media-controls" style="display:none;" class="mt-4">
            <button id="call-button" class="p-2 px-4 bg-green-500 text-white rounded">Start Call</button>
            <button id="hangup-button" style="display:none;" class="p-2 px-4 bg-red-500 text-white rounded">Hang Up</button>
        </div>
    </div>
    
    <div id="video-grid" class="flex flex-wrap gap-4 justify-center">
        <!-- Video elements will be added here -->
    </div>

    <div class="chat-section mt-4">
        <div class="sidebar p-4 bg-white rounded-lg shadow">
            <h3 class="text-xl font-semibold mb-2">Online Users</h3>
            <ul id="online-users-list"></ul>
        </div>

        <div class="chat-container p-4 bg-white rounded-lg shadow flex flex-col h-96">
            <h2 id="chat-title" class="text-xl font-semibold mb-2">Room Chat</h2>
            <div id="chatbox" class="flex-grow overflow-y-auto border-b pb-2 mb-2"></div>
            <form id="chat-input-form" class="flex">
                <input type="file" id="image-input" accept="image/*" style="display:none;">
                <button type="button" id="upload-image-button" class="p-2 bg-gray-200 text-xl rounded mr-2">üñºÔ∏è</button>
                <input type="text" id="chat-input" placeholder="Type a message..." autocomplete="off" class="flex-grow p-2 border rounded mr-2">
                <button type="submit" id="send-button" class="p-2 px-4 bg-blue-500 text-white rounded">Send</button>
            </form>
        </div>
    </div>

    <div class="active-rooms-container mt-4">
        <h2 class="text-xl font-semibold mb-2">Active Rooms</h2>
        <div id="active-rooms-list"></div>
    </div>
</div>

<script>
    // These variables will be initialized by the Firebase script in the head
    let app, db, auth, userId, isAuthReady;
    
    // UI elements
    const videoGrid = document.getElementById('video-grid');
    const chatbox = document.getElementById('chatbox');
    const chatInput = document.getElementById('chat-input');
    const chatInputForm = document.getElementById('chat-input-form');
    const roomInput = document.getElementById('room-input');
    const usernameInput = document.getElementById('username-input');
    const joinButton = document.getElementById('join-button');
    const statusMessage = document.getElementById('status-message');
    const mediaControls = document.getElementById('media-controls');
    const callButton = document.getElementById('call-button');
    const hangupButton = document.getElementById('hangup-button');
    const imageInput = document.getElementById('image-input');
    const uploadImageButton = document.getElementById('upload-image-button');
    const activeRoomsList = document.getElementById('active-rooms-list');
    const refreshRoomsButton = document.getElementById('refresh-rooms-button');
    const onlineUsersList = document.getElementById('online-users-list');
    const chatTitle = document.getElementById('chat-title');

    // App state
    let localStream = null;
    let localPeerId;
    let localUsername = localStorage.getItem('username') || '';
    let roomName;
    const peerConnections = {};
    const peerUsernames = {};
    const dmHistory = {};
    let currentChatTarget = 'room'; // 'room' or a user's peerId

    // WebRTC signaling via WebSocket
    const signalingServerUrl = 'wss://bhchat.onrender.com';
    let ws;
    const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    // Set initial username if it exists in local storage
    if (localUsername) {
        usernameInput.value = localUsername;
    }

    // --- Core App Functions ---

    // Initializes the chat and user presence listeners for the room
    function initializeRoomListeners() {
        if (!isAuthReady) {
            console.error("Firebase auth not ready.");
            return;
        }

        // Firestore collection paths
        const roomMessagesRef = collection(db, `artifacts/${appId}/public/data/rooms/${roomName}/messages`);
        const onlineUsersRef = collection(db, `artifacts/${appId}/public/data/rooms/${roomName}/onlineUsers`);

        // Real-time chat messages listener
        onSnapshot(roomMessagesRef, (snapshot) => {
            snapshot.docChanges().forEach(change => {
                const msg = change.doc.data();
                if (change.type === 'added') {
                    if (currentChatTarget === 'room') {
                        const isMyMessage = msg.senderId === userId;
                        if (msg.type === 'text') {
                            addMessageToChat(isMyMessage ? 'You' : msg.sender, msg.text, isMyMessage);
                        } else if (msg.type === 'image') {
                            addImageToChat(isMyMessage ? 'You' : msg.sender, msg.image, isMyMessage);
                        }
                    }
                }
            });
        });

        // Real-time online users listener with a "heartbeat"
        let userHeartbeatInterval = setInterval(() => {
            if (isAuthReady) {
                const userDocRef = doc(db, `artifacts/${appId}/public/data/rooms/${roomName}/onlineUsers`, userId);
                setDoc(userDocRef, { username: localUsername, lastSeen: serverTimestamp() }, { merge: true });
            }
        }, 10000); // Update every 10 seconds

        onSnapshot(onlineUsersRef, (snapshot) => {
            const users = {};
            snapshot.docs.forEach(doc => {
                const userData = doc.data();
                const now = Date.now();
                const lastSeen = userData.lastSeen ? userData.lastSeen.toDate().getTime() : now;
                // Consider users online if they've been seen in the last 15 seconds
                if (now - lastSeen < 15000) {
                    users[doc.id] = userData;
                }
            });
            displayOnlineUsers(users);
        });
    }

    // Connect to WebRTC signaling server
    function connectToSignalingServer() {
        ws = new WebSocket(signalingServerUrl);
        ws.onopen = () => {
            console.log('Connected to signaling server.');
            ws.send(JSON.stringify({ type: 'join_room', room: roomName, username: localUsername, peerId: userId }));
        };
        ws.onmessage = async (message) => {
            const data = JSON.parse(message.data);
            console.log('Received message:', data.type, 'from:', data.sender);

            if (data.type === 'room_joined') {
                localPeerId = data.peerId;
                statusMessage.textContent = `You are in room '${roomName}' as '${localUsername}'. Waiting for others...`;
                mediaControls.style.display = 'block';
            } else if (data.type === 'peer_joined') {
                if (data.peerId !== userId) {
                    peerUsernames[data.peerId] = data.username;
                    createPeerConnection(data.peerId);
                }
            } else if (data.type === 'offer') {
                if (data.sender !== userId) {
                    peerUsernames[data.sender] = data.username;
                    await handleOffer(data);
                }
            } else if (data.type === 'answer') {
                if (data.sender !== userId) {
                    peerUsernames[data.sender] = data.username;
                    await handleAnswer(data);
                }
            } else if (data.type === 'candidate') {
                if (data.sender !== userId) {
                    await handleCandidate(data);
                }
            } else if (data.type === 'peer_left') {
                removePeerConnection(data.peerId);
            } else if (data.type === 'active_rooms_list') {
                displayActiveRooms(data.rooms);
            }
        };
        ws.onclose = () => { console.log('Disconnected from signaling server.'); };
        ws.onerror = (error) => { console.error('WebSocket error:', error); };
    }

    // --- Event Handlers ---

    joinButton.onclick = () => {
        localUsername = usernameInput.value.trim();
        roomName = roomInput.value.trim();
        if (localUsername && roomName) {
            localStorage.setItem('username', localUsername);
            joinButton.disabled = true;
            statusMessage.textContent = `Joining room '${roomName}' as '${localUsername}'...`;
            joinRoom();
        } else {
            alert('Please enter a valid username and room name.');
        }
    };

    refreshRoomsButton.onclick = () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'get_active_rooms' }));
        } else {
            alert('Not connected to the signaling server.');
        }
    };

    function joinRoom() {
        if (!isAuthReady) {
            console.error("Firebase auth not ready, waiting...");
            return;
        }
        connectToSignalingServer();
        initializeRoomListeners();
    }
    
    chatInputForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const message = chatInput.value.trim();
        if (message === '') return;

        try {
            if (currentChatTarget === 'room') {
                const roomMessagesRef = collection(db, `artifacts/${appId}/public/data/rooms/${roomName}/messages`);
                await addDoc(roomMessagesRef, {
                    type: 'text',
                    sender: localUsername,
                    senderId: userId,
                    text: message,
                    timestamp: serverTimestamp()
                });
            } else {
                // For DMs, we store the chat history in a sub-collection on both users' documents
                const targetId = currentChatTarget;
                const dmMessage = {
                    type: 'text',
                    sender: localUsername,
                    senderId: userId,
                    text: message,
                    timestamp: serverTimestamp(),
                    recipientId: targetId
                };

                const myDmRef = collection(db, `artifacts/${appId}/public/data/rooms/${roomName}/onlineUsers/${userId}/dms`);
                await addDoc(myDmRef, dmMessage);
                
                const theirDmRef = collection(db, `artifacts/${appId}/public/data/rooms/${roomName}/onlineUsers/${targetId}/dms`);
                await addDoc(theirDmRef, dmMessage);

                // Add to local history for immediate display
                if (!dmHistory[targetId]) dmHistory[targetId] = [];
                dmHistory[targetId].push(dmMessage);
                addMessageToChat('You', message, true);
            }
            chatInput.value = '';
        } catch (e) {
            console.error("Error sending message:", e);
        }
    });

    uploadImageButton.onclick = () => { imageInput.click(); };

    imageInput.onchange = (event) => {
        const file = event.target.files[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                const imageData = e.target.result;
                try {
                    if (currentChatTarget === 'room') {
                        const roomMessagesRef = collection(db, `artifacts/${appId}/public/data/rooms/${roomName}/messages`);
                        await addDoc(roomMessagesRef, {
                            type: 'image',
                            sender: localUsername,
                            senderId: userId,
                            image: imageData,
                            timestamp: serverTimestamp()
                        });
                    } else {
                        const targetId = currentChatTarget;
                        const dmImage = {
                            type: 'image',
                            sender: localUsername,
                            senderId: userId,
                            image: imageData,
                            timestamp: serverTimestamp(),
                            recipientId: targetId
                        };
                        const myDmRef = collection(db, `artifacts/${appId}/public/data/rooms/${roomName}/onlineUsers/${userId}/dms`);
                        await addDoc(myDmRef, dmImage);
                        
                        const theirDmRef = collection(db, `artifacts/${appId}/public/data/rooms/${roomName}/onlineUsers/${targetId}/dms`);
                        await addDoc(theirDmRef, dmImage);
                        
                        if (!dmHistory[targetId]) dmHistory[targetId] = [];
                        dmHistory[targetId].push(dmImage);
                        addImageToChat('You', imageData, true);
                    }
                } catch (e) {
                    console.error("Error sending image:", e);
                }
            };
            reader.readAsDataURL(file);
        }
        imageInput.value = '';
    };


    // --- UI Helper Functions ---

    function addMessageToChat(sender, message, isMyMessage = false) {
        const messageElement = document.createElement('div');
        messageElement.textContent = `${sender}: ${message}`;
        messageElement.classList.add('message', 'p-2', 'rounded-lg', 'my-2', 'break-words');
        if (isMyMessage) {
            messageElement.classList.add('bg-blue-100', 'text-right', 'ml-auto');
        } else {
            messageElement.classList.add('bg-gray-100', 'text-left', 'mr-auto');
        }
        chatbox.appendChild(messageElement);
        chatbox.scrollTop = chatbox.scrollHeight;
    }

    function addImageToChat(sender, imageData, isMyMessage = false) {
        const messageElement = document.createElement('div');
        messageElement.classList.add('message', 'p-2', 'rounded-lg', 'my-2', 'break-words');
        if (isMyMessage) {
            messageElement.classList.add('bg-blue-100', 'text-right', 'ml-auto');
        } else {
            messageElement.classList.add('bg-gray-100', 'text-left', 'mr-auto');
        }

        const senderElement = document.createElement('span');
        senderElement.textContent = `${sender}: `;
        messageElement.appendChild(senderElement);

        const imageElement = document.createElement('img');
        imageElement.src = imageData;
        imageElement.classList.add('max-w-xs', 'rounded');
        messageElement.appendChild(imageElement);

        chatbox.appendChild(messageElement);
        chatbox.scrollTop = chatbox.scrollHeight;
    }

    async function displayOnlineUsers(users) {
        onlineUsersList.innerHTML = '';

        // Add "Room Chat" to the user list
        const roomChatListItem = document.createElement('li');
        roomChatListItem.textContent = `Room: ${roomName}`;
        roomChatListItem.classList.add('p-2', 'hover:bg-gray-100', 'cursor-pointer', 'rounded');
        if (currentChatTarget === 'room') {
            roomChatListItem.classList.add('active-chat');
        }
        roomChatListItem.onclick = async () => {
            currentChatTarget = 'room';
            chatTitle.textContent = `Room Chat: ${roomName}`;
            chatbox.innerHTML = '';

            // Load room history from Firestore
            const roomMessagesRef = collection(db, `artifacts/${appId}/public/data/rooms/${roomName}/messages`);
            const q = query(roomMessagesRef, orderBy('timestamp'));
            const querySnapshot = await getDocs(q);
            querySnapshot.forEach((doc) => {
                const msg = doc.data();
                const isMyMessage = msg.senderId === userId;
                if (msg.type === 'text') {
                    addMessageToChat(isMyMessage ? 'You' : msg.sender, msg.text, isMyMessage);
                } else if (msg.type === 'image') {
                    addImageToChat(isMyMessage ? 'You' : msg.sender, msg.image, isMyMessage);
                }
            });
        };
        onlineUsersList.appendChild(roomChatListItem);

        for (const peerId in users) {
            if (peerId !== userId) {
                const user = users[peerId];
                const listItem = document.createElement('li');
                listItem.textContent = user.username;
                listItem.classList.add('p-2', 'hover:bg-gray-100', 'cursor-pointer', 'rounded');
                if (currentChatTarget === peerId) {
                    listItem.classList.add('active-chat');
                }
                listItem.onclick = async () => {
                    currentChatTarget = peerId;
                    chatTitle.textContent = `DM with ${user.username}`;
                    chatbox.innerHTML = '';
                    
                    // Load DM history from Firestore
                    const dmRef = collection(db, `artifacts/${appId}/public/data/rooms/${roomName}/onlineUsers/${userId}/dms`);
                    const q = query(dmRef, where('recipientId', 'in', [peerId, userId]), where('senderId', 'in', [peerId, userId]), orderBy('timestamp'));
                    const querySnapshot = await getDocs(q);
                    querySnapshot.forEach(doc => {
                        const msg = doc.data();
                        const isMyMessage = msg.senderId === userId;
                        if (msg.type === 'text') {
                            addMessageToChat(isMyMessage ? 'You' : msg.sender, msg.text, isMyMessage);
                        } else if (msg.type === 'image') {
                            addImageToChat(isMyMessage ? 'You' : msg.sender, msg.image, isMyMessage);
                        }
                    });
                };
                onlineUsersList.appendChild(listItem);
            }
        }
    }

    async function displayActiveRooms(rooms) {
        activeRoomsList.innerHTML = '';
        if (Object.keys(rooms).length === 0) {
            activeRoomsList.innerHTML = '<p>No active rooms found.</p>';
            return;
        }

        const roomListElement = document.createElement('ul');
        for (const roomName in rooms) {
            const roomData = rooms[roomName];
            const listItem = document.createElement('li');
            listItem.textContent = `Room: ${roomName} | Active Users: ${roomData.count}`;
            
            const userList = document.createElement('ul');
            roomData.users.forEach(user => {
                const userItem = document.createElement('li');
                userItem.textContent = user;
                userList.appendChild(userItem);
            });
            listItem.appendChild(userList);

            roomListElement.appendChild(listItem);
        }
        activeRoomsList.appendChild(roomListElement);
    }
    
    // --- WebRTC Functions ---
    callButton.onclick = async () => {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            addLocalVideoElement();
            for (const peerId in peerConnections) {
                const pc = peerConnections[peerId];
                if (localStream) {
                    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
                }
                createOffer(pc, peerId);
            }
            callButton.classList.add('hidden');
            hangupButton.classList.remove('hidden');
        } catch (error) {
            console.error('Error getting user media:', error);
            alert('Could not get your camera and microphone. Please check permissions.');
        }
    };

    hangupButton.onclick = () => {
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }
        for (const peerId in peerConnections) {
            peerConnections[peerId].close();
            delete peerConnections[peerId];
        }
        videoGrid.innerHTML = '';
        callButton.classList.remove('hidden');
        hangupButton.classList.add('hidden');
    };
    
    function addLocalVideoElement() {
        const videoWrapper = document.createElement('div');
        videoWrapper.className = 'video-wrapper relative w-full sm:w-1/2 lg:w-1/3 p-2 bg-gray-900 rounded-lg shadow-lg';
        const video = document.createElement('video');
        video.id = `video-local-${userId}`;
        video.autoplay = true;
        video.playsinline = true;
        video.muted = true;
        video.srcObject = localStream;
        video.classList.add('w-full', 'rounded-lg');
        const label = document.createElement('div');
        label.className = 'absolute bottom-2 left-2 bg-black bg-opacity-50 text-white text-xs px-2 py-1 rounded';
        label.textContent = localUsername;
        videoWrapper.appendChild(video);
        videoWrapper.appendChild(label);
        videoGrid.appendChild(videoWrapper);
    }
    
    function createPeerConnection(peerId) {
        if (peerConnections[peerId]) {
            console.log(`Connection to peer ${peerId} already exists.`);
            return;
        }
        
        const pc = new RTCPeerConnection(configuration);
        peerConnections[peerId] = pc;
        
        if (localStream) {
            localStream.getTracks().forEach(track => {
                pc.addTrack(track, localStream);
            });
        }
        
        pc.ontrack = (event) => {
            const remoteUsername = peerUsernames[peerId] || `Peer ${peerId}`;
            addRemoteVideoElement(peerId, event.streams[0], remoteUsername);
        };
        
        pc.onicecandidate = (event) => {
            if (event.candidate) {
                ws.send(JSON.stringify({
                    type: 'candidate',
                    room: roomName,
                    targetPeer: peerId,
                    candidate: event.candidate,
                }));
            }
        };
    }
    
    async function createOffer(pc, peerId) {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({
            type: 'offer',
            room: roomName,
            targetPeer: peerId,
            description: pc.localDescription,
            username: localUsername,
        }));
    }
    
    async function handleOffer(data) {
        createPeerConnection(data.sender);
        const pc = peerConnections[data.sender];
        if (pc.signalingState !== 'stable') {
            await pc.setLocalDescription({ type: 'rollback' });
        }
        await pc.setRemoteDescription(new RTCSessionDescription(data.description));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        ws.send(JSON.stringify({
            type: 'answer',
            room: roomName,
            targetPeer: data.sender,
            description: pc.localDescription,
            username: localUsername,
        }));
    }
    
    async function handleAnswer(data) {
        const pc = peerConnections[data.sender];
        if (pc && pc.signalingState === 'have-local-offer') {
            await pc.setRemoteDescription(new RTCSessionDescription(data.description));
        }
    }
    
    async function handleCandidate(data) {
        const pc = peerConnections[data.sender];
        if (pc) {
            try {
                await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
            } catch (e) {
                console.error('Error adding received ICE candidate', e);
            }
        }
    }
    
    function removePeerConnection(peerId) {
        if (peerConnections[peerId]) {
            peerConnections[peerId].close();
            delete peerConnections[peerId];
        }
        const videoElement = document.getElementById(`video-${peerId}`);
        if (videoElement) {
            videoElement.parentNode.remove();
        }
    }
    
    function addRemoteVideoElement(peerId, stream, username) {
        if (document.getElementById(`video-${peerId}`)) return;
        
        const videoWrapper = document.createElement('div');
        videoWrapper.className = 'video-wrapper relative w-full sm:w-1/2 lg:w-1/3 p-2 bg-gray-900 rounded-lg shadow-lg';
        const video = document.createElement('video');
        video.id = `video-${peerId}`;
        video.autoplay = true;
        video.playsinline = true;
        video.srcObject = stream;
        video.classList.add('w-full', 'rounded-lg');
        const label = document.createElement('div');
        label.className = 'absolute bottom-2 left-2 bg-black bg-opacity-50 text-white text-xs px-2 py-1 rounded';
        label.textContent = username;
        videoWrapper.appendChild(video);
        videoWrapper.appendChild(label);
        videoGrid.appendChild(videoWrapper);
    }
</script>
</body>
</html>
